# INSTRUCTIONS  

This is your exam. Complete it either at exam.cs61a.org or, if that doesn’t work, by emailing course staff with your solutions before the exam deadline.  

This exam is intended for the student with email address <EMAILADDRESS>. If this is not your email address, notify course staff immediately, as each exam is different. Do not distribute this exam PDF even after the exam ends, as some students may be taking the exam in a different time zone.  

For questions with circular bubbles, you should select exactly one choice.  

$\bigcirc$ You must choose either this option $\bigcirc$ Or this one, but not both!  

For questions with square checkboxes, you may select multiple choices.  

You could select this choice. You could select this one too!  

You may start your exam now. Your exam is due at $<$ <DEADLINE $>$ Pacific Time. Go to the next pag to begin.  

# Preliminaries  

You can complete and submit these questions before the exam starts.  

(a) What is your full name?  

  

(b) What is your student ID number?  

  

# 1. (14.0 points) Down for the Count  

Definition. A digit is a non-negative integer less than 10. Integers contain digits.  

Examples.  

The integer 21 contains the digits 1 and 2.   
The integer 474 contains the digit 4 twice and the digit 7 once.   
The integer 400 contains the digit 4 once and the digit 0 twice.   
The integer -77 contains the digit 7 twice.   
The integer 0 is a 0-digit number that contains no digits.  

# Reminders.  

• You may call built-in functions that do not require import, such as min, max, abs, and pow. • You may call functions defined in earlier parts of the question in your implementation for later parts, and you may assume that the functions you call are implemented correctly.  

RESTRICTION. You may not call str or repr or use [ or ] in any part of this question.  

# (a) (4.0 points)  

Implement count, which takes a digit element and an integer box. It returns the number of times that element appears in box.  

Warning: n % d and n // d may not behave as you expect for negative n. For example, -123 % 10 evaluates to 7. -1 // 10 evaluates to -1. You do not need to know how these operators apply to negative n in order to solve this problem.  

def count(element, box): """Count how many times digit element appears in integer box. >>> count(2, 222122) 5 >>> count(0, -2020) 2 >>> count(0, 0) # 0 has no digits 0 ·… assert element $>=~0$ and element < 10  

(a) total $\mathit{\Theta}=\mathit{\Theta}0$ while box > 0: if (b) total $\mathbf{\Sigma}=\mathbf{\Sigma}$ (c) box $\mathbf{\Sigma}=\mathbf{\Sigma}$ box // 10 return total  

i. (2.0 pt) Fill in blank (a).  

  

ii. $\mathbf{(1.0\pt)}$ Which of these could fill in blank (b)?  

$\bigcirc$ box $\scriptstyle==$ element $\bigcirc$ box % $10~==$ element $\bigcirc$ box % element == 0 $\bigcirc$ box % element > 0 iii. $\mathbf{(1.0\pt)}$ Which of these could fill in blank (c)?  

total + 1   
element   
total $^+$ element   
box % 10   
total $^+$ box % 10  

# (b) (5.0 points)  

Implement count_nine, which takes a digit element and a non-negative integer box. It returns the number of times that element appears in box and is not adjacent to a 9.  

count_nine(element, box):   
"""Count how many times digit element appears in the non-negative i box in a place that is not next to a 9.   
>>> count_nine(2, 222122)   
5   
>>> count_nine(1, 1911191) # Only the middle 1 is not next to a 9 1   
>>> count_nine(9, 9)   
1   
>>> count_nine(9, 99)   
0   
>>> count_nine(3, 314159265359)   
2   
>>> count_nine(5, 314159265359)   
1   
$\ggg>>$ count_nine(9, 314159265359)   
2   
$\ggg>>$ count_nine(0, 0) # No digits are in 0   
0   
"""   
assert element $>=~0$ and element $\angle\cdot\angle$ 10   
assert box $>=~0$   
nine, total $\mathbf{\tau}=\mathbf{\tau}$ False, 0   
while box $>0$ :   
if and not (nine or   
(a) (b)   
total $\mathbf{\Sigma}=\mathbf{\Sigma}$   
(c)   
$\mathrm{nine}~=~\csc_{\mathrm{--},\mathrm{~(d)~}}==~9$   
box $\mathbf{\tau}=\mathbf{\tau}$ box // 10   
return total  

i. $({\bf1.0_{\nabla p t}})$ Which of these could fill in blank (a)?  

box $\scriptstyle==$ element box % $10\ ==$ element box % element $\scriptstyle==0$ box % element > 0 ii. (2.0 pt) Fill in blank (b).  

  

iii. $\mathbf{(1.0\pt)}$ Which of these could fill in blank (c)?  

total + 1   
element   
total $^+$ element   
box % 10   
total + box % 10  

iv. $\mathbf{(1.0\pt)}$ Fill in blank (d).  

  

# (c) (5.0 points)  

Implement fit, which takes two non-negative integers pegs and holes. It returns whether every digit in pegs appears at least as many times in holes as it does in pegs.  

def fit(pegs, holes): """Return whether every digit in pegs appears at least as many times in holes as it does in pegs. >>> fit(123, 321) # Each digit appears once in pegs and in holes. True >>> fit(1213, 33221) # 1 appears twice in pegs, but only once in holes. False $\ggg>>$ fit(12, 22) # 1 appears once in pegs, but not at all in holes. False $\ggg>>$ fit(314159, 112233456789) True $\dot{\textbf{i}}=\boldsymbol{0}$ while i ? (a) if (b) (c) i = i + 1 return (d)  

i. $\mathbf{(1.0\pt)}$ Fill in blank (a).  

  

ii. $\mathbf{\left(2.0\pt\right)}$ Fill in blank (b).  

  

iii. (1.0 pt) Fill in blank (c).  

iv. $\mathbf{(1.0\pt)}$ Which of these could fill in blank (d)?  

True False holes > pegs pegs $>$ holes holes >= pegs pegs $>=$ holes  

# 2. (8.0 points) Mystery Function  

Assume mystery is a deterministic pure function that takes one integer argument, returns an integer, and never errors.  

def mystery(n):   
Assume the following functions are also defined:   
def add_two(y): return y + 2   
def two(y): return 2   
def constant(k): def ignore(x): return k return ignore   
def diff(f, g): return lambda z: abs(f(z) - g(z))  

Definition. Two functions f and $\mathsf{g}$ have identical behavior if $\mathbf{f}\left(\mathbf{x}\right)$ and $\mathtt{g}(\mathtt{x})$ return equal values or return functions with identical behavior, for every $\mathbf{x}$ that does not cause an error.  

Complete each statement below so that it is true for all possible deterministic pure mystery functions.  

(a) $\mathbf{\left(2.0\pt\right)}$ The result of evaluating constant(2) has identical behavior to the result of evaluating the expression. . .  

add_two add_two(0) add_two(2) two two(0) . two(2) None of these  

(b) $\mathbf{\left(2.0\pt\right)}$ The result of evaluating diff(constant(1), constant(-1)) has identical behavior to the resul of evaluating the expression. . .  

constant constant(0) constant(2) diff(constant, constant) None of these  

(c) $\bf(2.0\nabla\ p t)$ The result of evaluating diff(mystery, mystery) has identical behavior to the result of evaluating the expression. . .  

constant constant(0) constant(2) diff(constant, constant) constant(mystery) mystery None of these  

(d) $\mathbf{\left(2.0\pt\right)}$ The result of evaluating diff(mystery, diff(mystery, mystery)) has identical behavior to the result of evaluating the expression. . .  

mystery abs(mystery) . lambda y: abs(mystery(y)) . lambda y: mystery(abs(y)) . lambda y: lambda z: mystery(abs(y)) - mystery(abs(z)) lambda y: lambda z: abs(mystery(y)) - abs(mystery(z)) . lambda y: lambda z: abs(mystery(y) - mystery(z)) None of these  

# 3. (8.0 points) Please Register to Vote  

Fill in each blank in the code example below so that its environment diagram is the following.  

RESTRICTIONS. You must use all of the blanks. Each blank can only include one statement or expression Click here to open the diagram in a new window  

  

def vote(vote):  

$$
\mathtt{p l e a s e\ =\ \underbrace{\_\mathrm{--}\_\mathrm{-}}_{\mathrm{(a)}}}
$$  

$$
\underbrace{\texttt{--}\texttt{--}}_{\mathrm{(b)}}=\texttt{t y}+\texttt{3}
$$  

return please  

$$
\boldsymbol{\mathsf{t y}}=\boldsymbol{\mathsf{1}}
$$  

register $\mathbf{\tau}=\mathbf{\tau}$ (lambda nov: nov $^+$ ty) (c)  

(d) register( (e)  

(a) $\mathbf{\left(2.0\pt\right)}$ Which of these could fill in blank (a)?  

vote(ty)   
vote(30)   
vote   
lambda nov: vote(nov) $^+$ third   
lambda nov: vote(nov $^+$ third)   
lambda nov: vote(nov) + ty   
lambda nov: vote(nov $^+$ ty)  

(b) $\mathbf{(1.0\pt)}$ Which of these could fill in blank (b)?  

third ty please vote  

(c) $\mathbf{(1.0\pt)}$ Which of these could fill in blank (c)?  

third ty please vote  

(d) $\mathbf{\left(2.0\pt\right)}$ Fill in blank (d).  

(e) $\mathbf{\left(2.0\pt\right)}$ Which of these could fill blank (e)? Check all that apply.  

ty \* 10 ty - 1 + 30 30 third + 26 口 (lambda x: x + x)(15)  

# 4. (10.0 points) Amazing Job Growth  

Definition. A repeatable function is a function that returns a repeatable function.  

Reminder. You may call built-in functions that do not require import, such as min, max, abs, and pow.  

(a) (4.0 points)  

Implement growth, which takes a number baseline and returns a repeatable function increase. When increase is called on a number observed, it prints the difference between observed and the smallest argument passed to growth or increase so far among the repeated calls.  

def growth(baseline): """Return a function that can be called repeatedly on numbers and prints the difference between its argument and the smallest argument used so far (including baseline).  

>>> job $\mathbf{\tau}=\mathbf{\tau}$ growth(148)(149)(150)(130)(133)(139)(137)   
1   
2   
0   
3   
9   
7   
"""   
def increase(observed): $\mathrm{under~\l=~\underbrace{\Sigma\Sigma\Sigma\Sigma}_{\Sigma\Sigma\Sigma\left(a\right)}-\Sigma\Sigma^{}--\Sigma}$ print(observed - under) return (b)   
return increase  

i. $\mathbf{\left(2.0\pt\right)}$ Fill in blank (a).  

ii. $\mathbf{\left(2.0\pt\right)}$ Which of these could fill in blank (b)?  

increase   
increase(under)   
increase(observed)   
increase(baseline)   
growth   
growth(under)   
growth(observed)   
growth(baseline)  

# (b) (6.0 points)  

Implement maxer, a higher-order function that takes a function smoke, which takes a number and returns a number. The maxer function returns a repeatable function fire that takes a number y and prints the largest result of calling smoke on any value of y passed to fire so far among the repeated calls.  

Assume that smoke is a deterministic pure function.  

def square $\left(\mathbf{\boldsymbol{x}}\right)$ : return x \* x   
def maxer(smoke): """Return a repeatable function fire(y) that prints the largest smoke(y) so far. >>> g = maxer(square) >>> h = g(2)(1)(3)(2)(-4) # print the largest square(y) so far 4 4 9 9 16 >>> h = maxer(abs)(2)(1)(3)(2)(-4) # print the largest abs(y) so far 2 2 3 3 4 """  

def fire(y):  

(a) def haze $(z)$ : if (b) z = y return (c) return haze return fire  

i. $\mathbf{\left(2.0\pt\right)}$ Fill in blank (a). You may not write a return statement for this blank.  

ii. (2.0 pt) Fill in blank (b).  

  

iii. $\mathbf{\left(2.0\pt\right)}$ Which of these could fill in blank (c)?  

smoke(y)  
fire(y)fire(smoke(y))  
haze  
haze(y)  
haze(smoke(y))smoke(z)fire(z)fire(smoke(z))  
haze(z)haze(smoke(z))  

No more questions.  