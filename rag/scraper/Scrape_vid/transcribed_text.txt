0.0-4.0:  Now we'll talk about the relationship between recursion and iteration.
4.0-10.0:  So there are cases when you want to convert a recursive function into an iterative implementation.
10.0-15.0:  And that can be tricky, because iteration is a special case of recursion.
15.0-20.0:  But for many functions there is a straightforward conversion into iteration.
20.0-23.0:  And the example we looked at before is one of those.
23.0-28.0:  So the idea is that you have to figure out what state needs to be maintained
28.0-32.0:  by the iterative function across each pass through the while statements.
32.0-36.0:  And so if we look at the sum digits function that we implemented earlier,
36.0-43.0:  we can look at what gets passed into some digits in each recursive call and what gets returned.
43.0-50.0:  And those are clues as to what we might need to give names to when we write an iterative version.
50.0-53.0:  So what gets passed in is what's left to some,
53.0-56.0:  which we call n here as a formal parameter.
56.0-63.0:  And what gets returned is a partial sum, the sum of the digits so far.
63.0-68.0:  So let's try to write an iterative version.
68.0-72.0:  Some digits iterative.
72.0-78.0:  Well, we're going to store the partial sum so far.
78.0-83.0:  And then, while n is greater than zero, meaning there are digits left to some,
83.0-90.0:  we will rebind n and last to the split up version of it.
90.0-93.0:  So n will become smaller than it was before.
93.0-96.0:  It will contain all but the last digit of what n was.
96.0-101.0:  And last, we'll contain the last digit.
101.0-109.0:  Then we can update digits sum to be whatever it was before plus last.
110.0-116.0:  And we'll eventually return digit sum.
120.0-124.0:  So we can still sum digits and we can now sum digits,
124.0-129.0:  it's an get the same answer.
129.0-132.0:  So by inspection, we figured out how to do that.
132.0-137.0:  It turns out that converting an iterative implementation using a wild statement
137.0-140.0:  to recursion is quite a bit more straightforward,
140.0-144.0:  precisely because iteration is a special case of recursion.
144.0-146.0:  So here's the story.
146.0-150.0:  When you look at an iterative implementation, you look for the state
150.0-154.0:  that is maintained across different iterations.
154.0-157.0:  And you just pass those in as arguments.
157.0-162.0:  So here's our iterative implementation of some digits.
162.0-165.0:  And the state that's maintained
165.0-170.0:  across each pass for the wild suite here is n,
170.0-174.0:  which changes to be all but the last digit of n,
174.0-179.0:  and the digit sum, which contains the partial sum of digits so far.
179.0-183.0:  So when we write a recursive version of the same thing,
183.0-189.0:  we pass in exactly that n and the digit sum so far.
189.0-193.0:  Instead of a wild statement that says,
193.0-196.0:  well n is greater than zero, we now have a base case
196.0-200.0:  that is exactly the opposite when one n equals zero,
200.0-202.0:  then we just return the digit sum.
202.0-210.0:  Otherwise, we execute the same thing as the suite of the wild statement.
210.0-217.0:  Except that we pass in the new values of n and the updated digit sum
217.0-220.0:  as arguments through a recursive call.
220.0-223.0:  The recursive call sum digits rec, on n,
223.0-227.0:  which is bound to all but the last digit of what was passed in,
227.0-231.0:  and then digit sum plus last is the sum so far.
231.0-236.0:  So updates via assignment become arguments to a recursive call.
236.0-241.0:  And this can be done quite generally for every iterative implementation.
